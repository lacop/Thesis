\chapter{Vizualizácie}
\todo[inline]{cd priloha/web, spustenie, requirements, ...}

Cieľom tejto práce je nielen popísať \obliv pamäťový model a rôzne dátové štruktúry v ňom, ale aj vytvoriť ich vizualizácie. Tie majú slúžiť na edukačné účely pre študentov (a učiteľov) a pomáhať pri pochopení ich fungovania.

Výsledkom práce sú vizualizácie demonštrujúce dátové štruktúry popísané v predchádzajúcich sekciách: \vEB usporiadanie (sekcia \ref{sec:static-obliv}) v statickom binárnom vyhľadávacom strome, usporiadané pole (\ref{sec:orderedfile}) a dynamický b-strom (\ref{sec:dynamic-obliv}). Súčasťou je tiež simulácia \cache (sekcia \ref{sec:extmem}) s možnosťou voľby parametrov $B$ a $M$ - veľkosť bloku a celková veľkosť.

\todo[inline]{Existujuce? nic nie je...}

\section{Gnarley trees}
Tieto vizualizácie sú implementované ako rozšírenie programu \emph{Gnarley trees}, ktorý vznikol ako súčasť bakalárskej práca Jakuba Kováča \citep{algviskuko}. Tento nástroj na vizualizáciu (prevažne stromových) dátových štruktúr bol následne v bakalárskych prácach \citep{algviskotrlova, algvistomkovic, algvislukca} a ročníkových projektoch rozšírený o mnohé ďalšie dátové štruktúry a v súčastnosti podporuje desiatky štruktúr, ako napríklad červeno-čierne, sufixové a intervalové stromy, \emph{union-find}, haldy a mnohé ďalšie.

\subsection{Funkcionalita}
Program umožňuje užívateľom zobrazovať tieto štruktúry a manipulovať s nimi. Všetky operácie sú rozložené na malé, jednoduché kroky a každý je vysvetlený keď sa vykonáva. Je možné posúvať sa po krokoch dopredu, ale aj vracať sa dozadu, a teda sa dá kedykoľvek vrátiť až k počiatočnému stavu. Toto je dôležité pri experimentovaní s danou štruktúrou, kedy dve rôzne operácie (alebo jedna operácia s dvoma rôznymi parametrami) spôsobia rôzne správanie a výsledky. Užívateľ má takto možnosť jednoducho sa po vykonaní prvej operácie vrátiť do predošlého stavu a preskúmať správanie druhej z nich.

Celý program je taktiež dvojjazyčný - je možné prepnúť medzi angličtinou a slovenčinou, čo umožňuje širšie použitie týchto vizualizácií.

\subsection{Prehľad programu}
\begin{figure}
    \centering
    \resizebox{0.9\textwidth}{!}{%
        \input{figures/screenshots/cobtree_menu}    
    }
    \caption{Užívateľské rozhranie počas operácie vkladania kľúča $10$ do dynamického \obliv B-stromu (sekcia \ref{sec:dynamic-obliv}).}
    \label{fig:ss_overview}
\end{figure}

Program sa skladá z troch hlavných častí (obrázok \ref{fig:ss_overview}). Najvrchnejšia časť okna tvorí hlavné menu, v ktorej môžeme voliť dátové štruktúry a prepínať jazyk rozhrania. Dátové štruktúry sú pre prehľadnosť rozdelené do niekoľkých kategórií. Tie popísané a implementované v tejto práci sa nachádzajú v kategórii \texttt{Cache-oblivious}.

V spodnej časti okna sa nachádza ovládací panel, ktorý obsahuje vstupné pole pre hodnotu, ktorú chceme vyhľadať alebo vložiť a tlačidlá na vykonanie týchto akcií. Ďalej obsahuje tlačidlá na prechod do ďalšieho kroku a návrat do predchádzajúceho stavu s možnosťou toto krokovanie vypnúť.

Najväčšia, prostredná časť okna zobrazuje vizualizáciu aktuálnej dátovej štruktúry. Toto zobrazenie je vektorové a je možné ho posúvať, približovať a oddialovať. Zároveň sa tu zobrazujú informácie o aktuálne vykonávanej akcií (ak je povolené krokovanie) a ďalšie vizualizačné prvky ako šípky alebo význačné vrcholy.

Podrobnejší popis užívateľského rozhrania a návod na používanie sa nachádza v bakalárskej práci Jakuba Kováča \citep{algviskuko} v siedmej kapitole.

\section{Statický strom}
Najjednoduchšou dátovou štruktúrou je statický vyhľadávací strom. Implementovali sme vytvorenie tohto stromu a jeho uloženie v pamäti. Je možné strom zväčšiť alebo zmenšiť podľa preferencii - ukážky stromov rôznych veľkostí sú na obrázku \ref{fig:ss_static_sizes}. Čísla vo vnútorných vrcholoch sú kľúče, čísla nad vrcholom určujú jeho pozíciu v pamäti. Obdĺžnik nad stromom reprezentuje uloženie tohto stromu v poli. Vnútorné čísla sú opäť kľúče, pričom sú zoradené podla svojich pozícii zľava (pozícia $1$) doprava.

\begin{figure}
    \centering
    \subtop[]{%
        \includegraphics[scale=0.25]{figures/screenshots/static_size_2.pdf}}
    \hspace{0.5cm}
    \subtop[]{%
        \includegraphics[scale=0.25]{figures/screenshots/static_size_3.pdf}}
    \hspace{0.5cm}
    \subtop[]{%
        \includegraphics[scale=0.25]{figures/screenshots/static_size_4.pdf}}
    \caption{Statické stromy rôznych veľkostí (výšok) vo \vEB usporiadaní.}
    \label{fig:ss_static_sizes}
\end{figure}

Medzi uložením vo \vEB usporiadaní a klasickom \emph{BFS} usporiadaní (ako v časti \ref{sec:static-naive}) je možné prepínať. Zmenia sa pritom čísla udávajúce pozície vrcholov v pamäti a ich poradie v poli nad stromom. Rozdiel medzi týmito dvoma usporiadaniami vidieť na obrázku \ref{fig:ss_static_order}. Pozície sa zhodujú s obrázkom \ref{fig:node_order_comparison}. \todo{ref to subfigure}

\begin{figure}
    \centering
    \subtop[]{%
        \includegraphics[width=\textwidth]{figures/screenshots/static_size_5.pdf}}
    \subtop[]{%
        \includegraphics[width=\textwidth]{figures/screenshots/static_size_5_bfs.pdf}}
    \caption{Rozdiel medzi \emph{BFS} a \vEB usporiadaním na strome výšky~$5$. Kľúče zostávajú rovnaké, líšia sa však ich pozície v pamäti reprezentované malými číslami nad vrcholmi a poľom nad koreňom.}
    \label{fig:ss_static_order}
\end{figure}

\subsection{Simulácia \cache}
Porovnanie týchto dvoch usporiadaní je rozšírené o simuláciu \cache. Užívateľ si môže zvoliť parametre cache - počet vrcholov $B$, ktoré sa zmestia do jedného bloku a počet blokov $\frac{M}{B}$ v \cache. Tiež je možné \cache kedykoľvek vyprázdniť -- odstrániť z nej všetky načítané bloky.

Táto simulácia zároveň počíta počet prístupov k vrcholom pri vyhľadávaní a počet presunutých blokov do \cache. V najhoršom prípade by tieto dve čísla boli rovnaké (ak treba každý vrchol načítať osobitne) avšak pri \cache s blokmi veľkosti $B > 1$ a s \vEB usporiadaním dochádza k podstatnému zlepšeniu - ušetreniu počtu presunutých blokov.

To môžeme vidieť na jednoduchom príklade, kedy v strome výšky $5$ postupne vyhľadáme všetkých $16$ kľúčov, ktoré sa nachádzajú v listoch tohto stromu. V oboch usporiadaniach bude počet prístupov rovnaký, avšak počet načítaní blokov z disku do \cache je v tomto príklade pri \emph{BFS} usporiadaní takmer dvakrát väčší ako pri \vEB usporiadaní. Obrázok \ref{fig:ss_cachesim_compare} ukazuje stav týchto štatistík po nájdení posledného listu.

\begin{figure}[h]
    \centering
    \subbottom[Strom v \emph{BFS} usporiadaní] {
        \includegraphics[width=6cm]{figures/screenshots/bmp_cache_panel_leaves_bfs}
    }
    \hspace{1cm}
    \subbottom[Strom vo \vEB usporiadaní] {
        \includegraphics[width=6cm]{figures/screenshots/bmp_cache_panel_leaves_veb}
    }
    \caption{Porovnanie štatistík simulovanej \cache po prechode listov $1,3,\dotsc,31$ stromu výšky $5$. Parametre cache sú v oboch prípadoch rovnaké ($B=4$, $M=2B=8$), rozdiel je však v usporiadaní v pamäti.}
    \label{fig:ss_cachesim_compare}
\end{figure}

Ako vizualizácia prítomnosti v \cache slúži farba - vrcholy a položky poľa obsahujúce kľúče majú svetlejšiu farbu pozadia v prípade, že je daný blok v \cache a tmavšiu ak je mimo. V strome je vďaka tomu ľahko vidieť, ktorá časť je načítaná a je možné ňou prechádzať bez ďalších presunov. V prípade \vEB usporiadanie pôjde prevažne o časť podstromu aktuálne porovnávaného vrcholu, avšak pri klasickom usporiadaní to budú práve vrcholy mimo tohto podstromu, o ktorých už vieme, že nie sú pri vyhľadávaní potrebné.

\begin{figure}
    \centering
    \subtop[Nultý krok]{%
        \includegraphics[width=0.25\textwidth]{figures/screenshots/cachesim_step1.pdf}}
    \hspace{1cm}
    \subtop[Prvý krok]{%
        \includegraphics[width=0.25\textwidth]{figures/screenshots/cachesim_step2.pdf}}
    \hspace{1cm}
    \subtop[Druhý krok]{%
        \includegraphics[width=0.25\textwidth]{figures/screenshots/cachesim_step3.pdf}}
    \caption{Simulácia \cache počas vyhľadávania kľúča $3$. Pred prvým prístupom je cache prázdna. V prvok kroku načítame koreň, ktorý je označený červenou farbou (\miss), keďže nebol v \cache. Spolu s ním sa v jednom bloku načítali ďalšie vrcholy, ktoré su označené svetlejšou farbou. V druhom kroku je vrchol s kľúčom $2$ označený zelenou farbou (\hit), keďže už bol do \cache načítaný v predchádzajúcom kroku.}
    \label{fig:ss_cachesim_colors}
\end{figure}

Pri krokovaní vyhľadávania je pri prístupe k vrcholu tiež použitá zelená alebo červená farba na jeho dočasné zafarbenie (podobne ako v časti \ref{sec:memaccess_patterns}) podľa toho, či sa v danom momente v \cache nachádzal (\hit) alebo nie (\miss). Ukážka tohto zafarbovania je na obrázku \ref{fig:ss_cachesim_colors}.

\section{Usporiadané pole}
\todo[inline]{Layout, intro}
\subsection{Vkladanie}

\section{Dynamický strom}
\todo[inline]{Layout, intro}
\subsection{Vyhľadávanie}
\subsection{Vkladanie}

\section{Implementácia}
\todo[inline]{?}

%Visualization
%- intro
%- existing - none?
%- algvis history
%- implementation details
%  - cache simulation
%- list of structures
%  - static tree
%    - intro
%    - array order
%    - cache simulation
%    - order switching
%  - ordered file
%    - intro
%    - insert
%  - cobtree
%    - intro
%    - layout
%    - find
%    - insert
%- testovanie?
