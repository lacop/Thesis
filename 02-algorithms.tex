\chapter{Cache-oblivius algoritmy a~dátové~štruktúry}

V tejto kapitole popíšeme niekoľko \obliv algoritmov a dátových štruktúr, spolu s ich pamäťovou analýzou v \obliv modeli. Zároveň uvedieme ekvivalentnú \aware dátovú štruktúru a vzájomne ich porovnáme. Najskôr sa však pozrieme na jeden jednoduchý príklad, ako túto analýzu riešime.

\section{Základný algoritmus}

Na demonštráciu \obliv algoritmov a ich analýzy v \extmem modeli použijeme jednoduchý algoritmus, ktorý počíta agregačnú funkciu nad hodnotami uloženými v poli. Uvažujeme pole $A = \{a_1,\dotsc,a_n\}$ a danú funkciu $g$ s počiatočnou hodnotou $g_0$. Chceme vypočítať hodnotu $f_g(A)$, kde $f_g$ je rozšírenie agregačnej funkcie definované následovne:
\[
\begin{aligned}
f_g(\{a_1,\dotsc,a_k\}) &= g(a_k, f(\{a_1,\dotsc,a_{k-1}\})) \\
f_g(\emptyset) &= g_0
\end{aligned}
\]
% f(1, 2, 3) = g(3, f(1, 2)) = g(3, g(2, f(1))) = g(3, g(2, g(1, g0)))

Túto funkciu je možné implementovať jednoducho ako jeden cyklus. Schematickú verziu implementácie uvádzame v algoritme \ref{alg:aggregate}. Tento algoritmus s použitím vhodnej funkcie $g$ a hodnoty $g_0$ je možné použiť na rôzne, často užitočné výpočty, ako napríklad maximum, minimum, suma a podobne:

\[
\begin{aligned}
g^{\textrm{max}}(x, y) &= \max(x, y) ~~ &g^{\textrm{max}}_0 &= -\infty \\
g^{\textrm{sum}}(x,y) &= x+y &g^{\textrm{sum}}_0 &= 0
\end{aligned}
\]

\begin{algorithm}
    \caption{Implementácia agregačnej funkcie $f_g$}
    \label{alg:aggregate}
    \begin{algorithmic}[1]
        \Function{aggregate}{$g, g_0, A$}
            \AlgLet{$y$}{$g_0$}
            \For{$i \gets 1,\dotsc,|A|$}
                \AlgLet{$y$}{$g(A[i], y)$}
            \EndFor
            \State \Return{$y$}
        \EndFunction
    \end{algorithmic}
\end{algorithm}


\subsection{Analýza zložitosti}
\subsubsection{Časová analýza}
Klasická časová analýza tohto algoritmu je triviálna ak uvažujeme \emph{RAM} model. Keďže prístup ku každému prvku \inlcode{A[i]} zaberie konštantný čas a za predpokladu, že čas na výpočet funkcie $g$ je nezávislý na vstupe, bude výsledný čas na výpočet tejto funkcie lineárny od veľkosti poľa $N$, teda $T(N) = \bigO{N}$.

\subsubsection{Analýza počtu pamäťových presunov}

V prípade \aware algoritmu by sme pole $A$ mali uložené v $\lceil \frac{N}{B} \rceil$ blokoch veľkosti $B$. Pri výpočte by sme postupne tieto bloky načítali do cache a pracovali s nimi. V rámci jedného bloku počas výpočtu nedochádza k pamäťovým presunom. Zároveň stačí každý prvok spracovať raz a teda celkový počet pamäťových operácií bude presne rovný počtu blokov, $\lceil \frac{N}{B} \rceil$. Tento algoritmus však požaduje znalosť parametra $B$ a zarovnať pole v pamäti tak, aby zabralo najmenší potrebný počet blokov.

Jednoducho však vieme dosiahnuť (takmer) rovnakú zložitosť aj v prípade \obliv algoritmu \ref{alg:aggregate}, ktorý žiadne parametre pamäte zjavne nevyužíva a nepozná. Budeme predpokladať, že pole $A$ je uložené v súvislom úseku pamäte - to je možné dosiahnuť aj bez znalosti parametrov pamäte. Zvyšok algoritmu prebieha rovnako ako v predchádzajúcom prípade. Každý blok obsahujúci nejaký prvok poľa $A$ bude teda presunutý do cache práve raz, a žiadne iné presuny nenastanú. Ostáva zistiť, koľko takých blokov môže byť.

Keďže nepoznáme veľkosti blokov v pamäti, nevieme pri ukladaní prvkov poľa zaručiť zarovnanie so začiatkom bloku. V najhoršom prípade uložíme do prvého bloku iba jeden prvok. Potom bude nasledovať $\lfloor \frac{N}{B} \rfloor$ plných blokov a nakoniec ešte najviac jeden blok, ktorý opäť nie je plný. Spolu máme teda $\lfloor \frac{N}{B} \rfloor + 2$ blokov.

Pokiaľ $\lfloor \frac{N}{B} \rfloor < \lceil \frac{N}{B} \rceil$ máme spolu najviac $\lceil \frac{N}{B} \rceil + 1$ blokov. V opačnom prípade $B$ delí $N$, teda v prvom a poslednom bloku je spolu presne $B$ prvkov a medzi nimi sa nachádza najviac $\frac{N-B}{B} = \frac{N}{B} - 1$ plných. Teda blokov je vždy najviac $\lceil \frac{N}{B} \rceil +1$.

Zostrojili sme teda \obliv algoritmus s asymptoticky rovnakou zložitosťou $\bigO{\frac{N}{B}}$ ako optimálny \aware algoritmus, ktorého implementácia je však jednoduchšia, keďže nemusí explicitne spravovať presun blokov do cache. Parameter $B$ sme použili len počas analýzy, v samotnom návrhu algoritmu nie.

\section{Vyhľadávanie v statickej množine}
Častým problémom v informatike je nutnosť rýchlo a efektívne vyhľadávať prvok v nejakej statickej množine prvkov. Tento problém by šiel riešiť hašovaním, budeme však uvažovať usporiadanú množinu, v ktorej chceme vedieť efektívne pristúpiť k predchádzajúcemu a nesledujúcemu prvku. V tejto sekcii popíšeme niekoľko algoritmov a dátových štruktúr, ktoré tento problém riešia. Všetky majú v \emph{RAM} modeli časovú zložitosť $\bigO{\log N}$, kde $N$ je počet prvkov v prehľadávanej množine, no v \aware a \obliv modeloch sa budú líšiť počtom pamäťových presunov, ktoré vykonajú.

Tento rozdiel je spôsobený iným usporiadaním prvkov v pamäti. Keďže majú všetky uvedené prístupy logaritmickú časovú zložitosť bude počet presunutých blokov najviac $\bigO{\log{N}}$. V tomto odhade však nevystupujú žiadne parametre \cache a teda ich zväčšenie tento algoritmus nemusí urýchliť. Ukážeme ale dátovú štruktúru, ktorá dosahuje podstatne lepší výsledok $\bigO{\log_B{N}}$ a bude nám tiež slúžiť ako základ pri riešení dynamickej verzie tohto problému.

\subsection{Binárne vyhľadávanie}
Ako prvé popíšeme binárne vyhľadávanie, ktoré je asi najznámejšie. V algoritme \ref{alg:binsearch} uvádzame implementáciu, ktorá nájde prvok $K$ v usporiadanom poli \inlcode{A[$0,\dotsc,N-1$]}, pre ktoré platí $\forall i,j;~ 0\le i < j < N: \texttt{A[}i\texttt{]} \le \texttt{A[}j\texttt{]}$.

\begin{algorithm}
    \caption{Implementácia binárneho vyhľadávania}
    \label{alg:binsearch}
    \begin{algorithmic}[1]
        \Function{find}{$A, K$}
            \AlgLet{$left$}{$0$}
            \AlgLet{$right$}{$N$}
            \While{$left < right$}
                \AlgLet{$mid$}{$\lfloor\frac{left+right}{2}\rfloor$}
                \If{$A[mid] = K$}
                    \State \Return{$mid$}
                \ElsIf{$A[mid] > K$}
                    \AlgLet{$right$}{$mid$}
                \Else
                    \AlgLet{$left$}{$mid+1$}
                \EndIf
            \EndWhile
            \State \Return{$K \notin A$}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

Vidíme, že táto implementácia binárneho vyhľadávania nikde nepožaduje znalosť parametrov $B$ ani $M$ a teda ide o \obliv algoritmus, tak ako v prípade agregačného algoritmu $\ref{alg:aggregate}$.

\subsubsection{Analýza zložitosti}
Pri každej iterácií zmenšíme oblasť, ktorú treba preskúmať na polovicu. Počet iterácií a celková zložitosť bude teda riešenie rekurentného vzťahu
\[
T(N) = T(N/2) + \bigO{1}
\]
V prípade časovej analýzy je bázou rekurencie $T(1) = \bigO{1}$ a výsledná časová zložitosť bude $T(N) = \bigO{\log N}$.

Pri pamäťovej analýze bude bázou $T(B) = \bigO{1}$, pretože po zredukovaní prehľadávaného intervalu na veľkosť $B$ vieme všetky potenciálne prvky načítať v $\bigO{1}$ blokoch a k ďalším presunom už nedôjde. Riešením a celkovou pamäťovo zložitosťou teda bude $T(N) = \bigO{\log{N}-\log{B}} = \bigO{\log{\frac{N}{B}}}$.

Ako však uvidíme v ďalšej sekcii, toto riešenie nie je optimálne.

%Ďalším jednoduchým algoritmom je binárne vyhľadávanie, ktorým vieme nájsť kľúč $K$ v usporiadanom poli $A$ veľkosti $N$ v čase $\bigO{\log N}$. 

%\section{Vyhľadávacie stromy}

%Jednou z najzákladnejších, no zároveň najdôležitejších a najpoužívanejších dátových štruktúr sú vyhľadávacie stromy. Tie umožňujú ukladať kľúče v istom usporiadaní a podporujú operácie vkladania a vyhľadávania v čase závislom od výšky stromu. Jedným z mnohých variantov sú B-stromy \citep{bayerbtree}, ktoré majú variabilný faktor vetvenia. To je dôležitá vlasnosť pri \extmem modely a ako popíšeme v sekcii \ref{sec:static-aware} je ich možné jednoducho použiť na dosiahnutie asymptoticky optimálneho riešenia.

\subsection{\Aware riešenie} \label{sec:static-aware}
V prípade, že poznáme veľkosť blokov $B$ v cache, môžeme problém vyhľadávacích stromov riešiť B-stromom \citep{bayerbtree} s vetvením $\Theta(B)$. Každý vrchol teda vieme načítať s použitím $\bigO{1}$ pamäťových presunov. Výška takého B-stromu, ktorý má $N$ listov, bude $\bigO{\log_B{N}}$. Celkovo teda vyhľadávanie v tomto strome vykoná $\bigO{\log_B{N}}$ pamäťových presunov.

Toto je lepší výsledok ako dosahuje binárne vyhľadávanie. Stále však zostáva otázka, či neexistuje  ešte efektívnejšie riešenie. Pozrime sa teda na spodnú hranicu tohto problému.
%To zodpovedá dolnej hranici v predchádzajúcej sekcii a teda toto riešenie je asymptoticky optimálne.

\subsection{Spodná hranica pre vyhľadávanie} \label{sec:tree-lowerbound}
Pri vyhľadávaní potrebujeme pristúpiť k aspoň $\Omega(\log{N})$ prvkom. Tie by v ideálnom prípade boli uložené v $\Omega(\frac{\log{N}}{B})$ blokoch, čo tvorí spodnú hranica počtu pamäťových presunov. Tento odhad je ale príliš optimistický -- ako ukážeme odvodením väčšej spodnej hranice, nie je možné ho dosiahnuť.

Toto odvodenie spravíme rovnako ako v \citep{demaineoverview} technikou informačnej zložitosti. Na nájdenie daného prvku v množine obsahujúcej $N$ položiek potrebujeme získať $\lg(2N+1)$ informačných bitov reprezentujúcich pozíciu tohto prvku -- $N$ možných existujúcich prvkov a $N+1$ pozícií medzi nimi (a na okrajoch) pre neexistujúci prvok. V každom pamäťovom presune načítame jeden blok veľkosti $B$, ktorý môže obsahovať najviac $\lg(2B+1)$ bitov informácie -- hľadaný prvok je jeden z týchto $B$ prvkov alebo patrí v usporiadaní niekam medzi ne. V najlepšom prípade je teda potrebných aspoň
\[
\frac{\lg(2N+1)}{\lg(2B+1)} \ge \frac{\lg N}{\lg B} = \Omega(\log_B{N})
\]
pamäťových presunov. Tento odhad je na rozdiel od predchádzajúceho dosiahnuteľný, napríklad práve \aware B-stromami.

Vidíme teda, že na rozdiel od \obliv binárneho vyhľadávania, je \aware B-strom asymptoticky optimálnym riešením tohto problému. Chceli by sme teraz nájsť \obliv dátovú štruktúru, ktorá tiež dosahuje túto hranicu.

\subsection{Naivné \obliv riešenie} \label{sec:static-naive}
Predtým ako popíšeme efektívne \obliv riešenie, sa pozrime na klasický binárny vyhľadávací strom. Asi najjednoduchší spôsob, ako usporiadať uzly (statického) binárneho stromu v pamäti, je nasledovný. Koreň uložíme na pozíciu $1$. Ľavého a pravého potomka vrcholu na pozícii $x$ uložíme na pozície $2x$ a $2x+1$. Otec vrcholu $x$ bude teda na pozícii $\lfloor\frac{x}{2}\rfloor$. Toto usporiadanie voláme \emph{BFS usporiadanie} (z anglického \emph{breadth-first search} -- prehľadávanie do šírky), keďže pozície vrcholov sa zvyšujú v rovnakom poradí ako by prebiehalo prehľadávanie tohto stromu do šírky. Príklad takto uloženého stromu je na obrázku \ref{fig:node_order_naive}.

Výhodou tohto usporiadania sú implicitné vzťahy medzi vrcholmi. Na udržiavanie stromu stačí jednorozmerné pole kľúčov. Na prechod medzi nimi môžeme použiť triviálne funkcie uvedene v algoritme \ref{alg:naive_indexing}.

\begin{algorithm}[H]
	\caption{Funkcie pre získanie pozícií ľavého syna, pravého syna a rodiča vrcholu na pozícii $x$}
    \label{alg:naive_indexing}
	\begin{minipage}[t]{0.3\textwidth}
	    \begin{algorithmic}[1]
	        \Function{left}{$x$}
	            \State \Return{$2x$}
	        \EndFunction
	    \end{algorithmic}
	\end{minipage} \hfill
	\begin{minipage}[t]{0.3\textwidth}
	    \begin{algorithmic}[1]
	        \Function{right}{$x$}
	            \State \Return{$2x+1$}
	        \EndFunction
	    \end{algorithmic}
	\end{minipage} \hfill
	\begin{minipage}[t]{0.3\textwidth}
	    \begin{algorithmic}[1]
	        \Function{parent}{$x$}
	            \State \Return{$\lfloor\frac{x}{2}\rfloor$}
	        \EndFunction
	    \end{algorithmic}
	\end{minipage}
\end{algorithm}

Nevýhodou je však vysoký počet pamäťových presunov pri vyhľadávaní. Výška tohto stromu je\footnote{Nejde o vyvažovaný binárny strom a teda by výška mohla byť až $\bigO{N}$. Keďže však pracujeme so statickými dátami, môžeme ich vopred usporiadať a vyrobiť vyvážený statický strom} $\bigO{\log{N}}$. Pri načítaní vrcholu na pozícii $x$ sa v rovnakom bloku nachádzajú vrcholy na pozíciach
\[
x-k,\dotsc,x-1,x,x+1,\dotsc,x+l
\]
kde $k+l=B-1$. Pri ďalšom kroku vyhľadávania budeme potrebovať vrchol $2x$ alebo $2x+1$ a teda nás pozície menšie ako $x$ nezaujímajú. V najlepšom prípade teda bude $k=0$ a $l=B-1$. Aby sa v tomto intervale nachádzali požadované vrcholy, musí platiť
\[
\begin{aligned}
2x+1 &\le x+l = x+B-1 \\
x &\le B-2
\end{aligned}
\]
To znamená, že pre pozície $x > B - 2$ už bude potrebný pamäťový presun pre každý vrchol. Vrchol s pozíciou $B-2$ bude mať hĺbku $\bigO{\log{B}}$ a teda počet vrcholov na ceste z koreňa do listu, ktorých pozície v pamäti sú väčšie ako $B-2$ bude $\Omega(\log{N}-\log{B})$. Pre každý z nich je potrebné vykonať pamäťový presun a teda vyhľadávanie v takto usporiadanom binárnom strome vykoná $\Omega(\log{\frac{N}{B}})$ pamäťových presunov, čo je rovnako ako binárne vyhľadávanie horšie v porovnaní s \aware B-stromom.

\subsection{Vyhľadávací strom vo \vEB{ovom} usporiadaní} \label{sec:static-obliv}
Problémom predošlého riešenia je neefektívne usporiadanie v pamäti - pri prístupe ku vrcholu sa spolu s ním v rovnakom bloku nachádzajú vrcholy, ktoré nie sú pre ďalší priebeh algoritmu podstatné. 

Možným riešením je takzvané \vEB{ovo} \emph{usporiadanie} (\vEB{} \emph{layout}, nazvané podla \vEB{ových} stromov s podobnou myšlienkou), ktoré popísali Bender \etal\citep{btreeshort, btreefull}. Toto usporiadanie vznikne rekurzívnym delením, ktoré schéma je na obrázku \ref{fig:veblayout_scheme} a príklad takto uloženého stromu na obrázku \ref{fig:node_order_veb}.

Uvažujme úplný binárny strom výšky $h$. Ak $h=1$ tak máme iba jeden vrchol $v$ a výstupom usporiadania bude poradie $(v)$.

Pre $h>1$ označme $m = \max_{i\in\mathbb{N}}\{2^i \mid 2^i < h\}$, teda najväčšiu mocninu dvoch menšiu ako $h$. Rozdelíme vstupný strom na podstrom $\tau_0$ výšky $h-m$, ktorého koreňom je koreň pôvodného stromu. Zostanú nám podstromy $\tau_1,\dotsc,\tau_k$ výšky $m$ (obrázok \ref{fig:veblayout_scheme}). Korene týchto podstromov sú potomkovia listov $\tau_0$ a ich z listy sú listy vstupného stromu. Všetky tieto podstromy majú približne polovičnú výšku a teda ich veľkosť je $\Theta(\sqrt{N})$ kde $N$ je veľkosť vstupného stromu, keďže $\frac{h}{2} = \frac{1}{2}\lg{N} = \lg{\sqrt{N}}$. Rekurzívne ich uložíme do \vEB{ovho} usporiadania a následne uložíme za seba, výstupom teda bude poradie $(\tau_0,\tau_1,\dotsc,\tau_k)$.

\begin{figure}
    \centering
    \resizebox{0.9\textwidth}{!}{
        \input{figures/vEB_tree/vEBlayout_scheme}
    }
    \caption[Schematické znázornenie rekurzívneho delenia]{Schematické znázornenie rekurzívneho delenia pri \vEB{ovom} usporiadaní. Podstromy $\tau_0,\dotsc,\tau_k$ sa uložia do súvislého úseku pamäte.}
    \label{fig:veblayout_scheme}
\end{figure}

\begin{figure}
    \centering
    \subbottom[Klasické usporiadanie] {
        \resizebox{\textwidth}{!}{
            \input{figures/vEB_tree/node_order_naive}
        }
        \label{fig:node_order_naive}
    }
    \subbottom[\vEB{ovo} usporiadanie] {
        \resizebox{\textwidth}{!}{
            \input{figures/vEB_tree/node_order_veb}
        }
        \label{fig:node_order_veb}
    }
    \caption[Porovnanie klasického a \vEB{ovho} usporiadania]{Porovnanie klasického a \vEB{ovho} usporiadania na úplnom binárnom strome výšky $5$. Čísla vo vrcholoch určujú poradie v pamäti.}
    \label{fig:node_order_comparison}
\end{figure}

\subsubsection{Prechod stromom v pamäti}
Na rozdiel od klasického \emph{BFS} usporiadania nie je pri takomto usporiadaní v pamäti triviálne zistiť, na akej pozícii sa nachádzajú potomkovia alebo rodič aktuálneho vrcholu. Jedným možným riešením je spolu s každým vrcholom ukladať aj ukazovateľ na tieto relevantné vrcholy. Tým znížime počet vrcholov, ktoré sa zmestia do jedného bloku o konštantný násobok -- v prípade, že je kľúč rovnako veľký ako ukazovateľ, bude počet vrcholov v jednom bloku štvrtina pôvodného počtu.

Iným riešením je vnútorne pracovať s \emph{BFS} usporiadaním a prechádzať medzi pozíciami funkciami uvedenými v algoritme \ref{alg:naive_indexing}. Pri prístupe k vrcholu túto \emph{BFS} pozíciu prevedieme na ekvivalentnú pozíciu vo \vEB{ovom} usporiadaní. Pri strome s $N$ vrcholmi je možné túto konverziu realizovať v čase $\bigO{\log\log N}$ \citep{kasheff2004cache}.

\subsubsection{Vyhľadávanie} \label{sec:static-search}

Pri analýze vyhľadávania sa pozrime na také podstromy predošlého delenia, že ich veľkosť je $\Theta(B)$. Ďalšie delenie a preusporiadanie je už zbytočné, no to \obliv algoritmus nemá ako vedieť. Keďže ale po rekurzívnom volaní získame len iné usporiadanie, ktoré uložíme v súvislom úseku pamäte, bude stále možné tento podstrom načítať v $\bigO{1}$ blokoch.

Majme teda vyhľadávací strom zložený z takýchto podstromov, ktorých veľkosť je medzi $\Omega(\sqrt{B})$ a $\bigO{B}$. Ich výška je teda $\Theta(\log{B})$. Pri strome výšky $\bigO{\log N}$ teda prejdeme cez $\bigO{\frac{\log{N}}{\log{B}}}$ takých podstromov a každý vyžaduje konštantný počet pamäťových presunov. Spolu sa ich teda vykoná $\bigO{\log_B{N}}$, čo zodpovedá spodnej hranici tohto problému.

\subsection{Rozdiely v prístupe ku pamäti} \label{sec:memaccess_patterns}
Rozdiely medzi binárnym vyhľadávaním a statickými vyhľadávacími stromami v \emph{BFS} a \vEB{} usporiadaniach vizuálne znázorňujú obrázky \ref{fig:search_comparison1} a \ref{fig:search_comparison2} na strane \pageref{fig:search_comparison1}. Pozrime sa však najskôr na menší obrázok \ref{fig:search_comparison_small}, na ktorom vysvetlíme princíp tejto vizualizácie.

\begin{figure}[h]
    \centering
    \subtop[Binárne vyhľadávanie] {
        \resizebox{0.3\textwidth}{!} {
            \input{figures/search_comparison/small_binsearch}
        }
    }
    \subtop[\emph{BFS} strom] {
        \resizebox{0.3\textwidth}{!} {
            \input{figures/search_comparison/small_bfstree}
        }
    }
    \subtop[\vEB{ov} strom] {
        \resizebox{0.3\textwidth}{!} {
            \input{figures/search_comparison/small_vebtree}
        }
    }
    \caption[Porovnávanie prístupov ku pamäti pri vyhľadávaní hodnoty $17$]{Porovnávanie prístupov ku pamäti v rôznych štruktúrach pri vyhľadávaní hodnoty $17$ medzi $31$ prvkami}
    \label{fig:search_comparison_small}
\end{figure}

Jednotlivé políčka sú položky poľa, pričom v pamäti sú usporiadané v poradí zhora nadol a zľava doprava. Samotné kľúče (vo vrcholoch stromov) sú však usporiadané inak a preto sú tieto prístupy inak efektívne. Vo všetkých prípadoch vyhľadávame prvok v množine $\{1, \dotsc, 2^h-1\}$, čo je počet vrcholov úplného binárneho stromu výšky $h$. Farby označujú stav políčka v simulovanej \cache s veľkosťou bloku $B=4$. Bloky sú v zarovnané tak, že jeden stĺpec predstavuje jeden blok a teda sa pri načítaní ľubovolného políčka spolu s ním načíta celý príslušný stĺpec.

Červená farba reprezentuje prvky, ktoré sa v momente prístupu nenachádzali v \cache a bolo potrebné ich načítať (\miss). Zelená naopak označuje prvky, ktoré už v \cache boli (\hit) -- načítali sa spolu s nejakým červeným prvkom v rovnakom bloku. Ostatné prvky, ktoré sa načítali ako súčasť bloku ale neboli použité, sú označené žltou farbou. V tejto simulácii je počet blokov v \cache ($\frac{M}{B}$) pre jednoduchosť neobmedzený.

V malom obrázku \ref{fig:search_comparison_small} (výška stromu $h=5$) šípky určujú poradie, v akom vyhľadávanie pristupovalo k jednotlivým prvkom. Vo veľkých obrázkoch \ref{fig:search_comparison1} a \ref{fig:search_comparison2} (výška stromu $h=9$) sú šípky pre prehľadnosť vynechané a políčko s bodkou označuje pozíciu, na ktorej bol napokon požadovaný prvok nájdený. Rozdiely medzi týmito troma prístupmi k vyhľadávaniu je lepšie vidieť práve na väčších obrázkoch.

Keďže všetky hľadané hodnoty boli zvolené ako listy týchto vyhľadávacích stromov, pristúpili operácie vyhľadávania vo všetkých troch prípadoch práve k $h$ prvkom. Rozdiel je však v pomere počtu červených (ktoré v \cache neboli a bolo ich potrebné načítať) a zelených (na ktoré nebol potrebný pamäťový presun) prvkov.

Ako ľahko vidieť, binárne vyhľadávanie začne v strede a presúva sa medzi prvkami, ktoré sú od seba  čoraz menej vzdialené až do momentu, kedy už je prehľadávaný interval dostatočne malý na to, aby sa zmestil do bloku.

Naopak strom v \emph{BFS} usporiadaní robí stále väčšie a väčšie \emph{skoky} a porovnávané prvky sa do jedného bloku zmestia iba na začiatku.

Avšak strom vo \vEB{ovom} usporiadaní potom čo pristúpi k nejakému prvku v ďalších krokoch pristupuje k prvkom, ktoré sú v pamäti blízko a veľký \emph{skok}, ktorý pristúpi mimo \cache, vykonáva menej často. Vďaka tomu dosahuje v oboch príkladoch najlepší počet zásahov do \cache, teda najviac zelených políčok.

% 243 binsearch   G:2 R:7
% 243 bfs         G:1 R:8
% 243 veb         G:5 R:4
%
% 427 binsearch   G:2 R:7
% 427 bfs         G:1 R:8
% 427 veb         G:4 R:5


\begin{sidewaysfigure}
    \centering
    \subbottom[Binárne vyhľadávanie] {
        \resizebox{\textwidth}{!}{
            \input{figures/search_comparison/height9_find243_binsearch}
        }
    }
    \subbottom[Strom v \emph{BFS} usporiadaní] {
        \resizebox{\textwidth}{!}{
            \input{figures/search_comparison/height9_find243_bfstree}
        }
    }
    \subbottom[Strom vo \vEB{ovom} usporiadaní] {
        \resizebox{\textwidth}{!}{
            \input{figures/search_comparison/height9_find243_vebtree}
        }
    }
    \caption[Porovnávanie prístupov ku pamäti pri vyhľadávaní hodnoty $243$]{Porovnávanie prístupov ku pamäti v rôznych štruktúrach pri vyhľadávaní hodnoty $243$ medzi $511$ prvkami}
    \label{fig:search_comparison1}

    \vspace*{2cm}
        
    \subbottom[Binárne vyhľadávanie] {
        \resizebox{\textwidth}{!}{
            \input{figures/search_comparison/height9_find427_binsearch}
        }
    }
    \subbottom[Strom v \emph{BFS} usporiadaní] {
        \resizebox{\textwidth}{!}{
            \input{figures/search_comparison/height9_find427_bfstree}
        }
    }
    \subbottom[Strom vo \vEB{ovom} usporiadaní] {
        \resizebox{\textwidth}{!}{
            \input{figures/search_comparison/height9_find427_vebtree}
        }
    }
    \caption[Porovnávanie prístupov ku pamäti pri vyhľadávaní hodnoty $427$]{Porovnávanie prístupov ku pamäti v rôznych štruktúrach pri vyhľadávaní hodnoty $427$ medzi $511$ prvkami}
    \label{fig:search_comparison2}
\end{sidewaysfigure}

\subsection{Dynamická verzia vyhľadávacieho stromu} 
V časti \ref{sec:static-obliv} sme popísali štruktúru, ktorá dokáže vyhľadávať v usporiadanej statickej množine optimálne, rovnako ako \aware B-stromy. Problémom tejto dátovej štruktúry je však nemožnosť efektívne vkladať či odoberať prvky - pri každej zmene by bolo potrebné strom preusporiadať. Dostávame tak \obliv ekvivalent statických \aware B-stromov. 

Na úpravu tohto statického stromu tak, aby efektívne zvládal operácie pridávania a odstraňovania, budeme potrebovať pomocnú dátovú štruktúru, ktorú popíšeme v následovnej sekcii.

\section{Usporiadané pole} \label{sec:orderedfile}

Problémom \emph{údržby usporiadaného poľa} (z anglického \emph{ordered-file maintenance}) budeme volať problém spočívajúci v udržiavaní zoradenej postupnosti $N$ prvkov vo forme súvislého poľa veľkosti $\bigO{N}$. V tomto poli teda môžu byť \emph{medzery} veľkosti najviac $\bigO{1}$, vďaka čomu bude načítanie $K$ po sebe idúcich prvkov vyžadovať $\bigO{\frac{K}{B}}$ pamäťových presunov. Do tejto postupnosti musí byť možné efektívne vkladať prvky na ľubovoľnú danú pozíciu a tiež odstraňovať existujúce prvky.

Dátovou štruktúrou, ktorá tento problém rieši efektívne je \emph{štruktúra zhustenej pamäte} (\emph{packed-memory structure}). Myšlienka tejto štruktúry spočíva v zostrojení binárneho stromu nad prvkami tohto poľa a  udržiavaní \emph{hustoty} -- podielu plných a všetkých pozícií -- pre každý vrchol v konštantných hraniciach. Tým zaručíme, že štruktúra nebude ani príliš plná, čo by spôsobovalo pri vkladaní nutnosť presúvať veľké množstvo existujúcich prvkov na uvoľnenie miesta, a ani príliš prázdna, čo by spôsobovalo pomalé prechádzanie kvôli veľkým medzerám.

\subsection{Popis štruktúry} \label{sec:of-desc}

Budeme používať verziu z \citep{btreeshort} s malými úpravami. Celá dátová štruktúra pozostáva z jedného poľa veľkosti $T = 2^h$. To (pomyselne) rozdelíme na \emph{bloky} veľkosti $S=\Theta(\log{N})$, tak aby $S = 2^l$. Počet blokov tak bude tiež mocnina dvoch.

\begin{figure}
    \centering
    \resizebox{0.8\textwidth}{!}{
        \input{figures/ordered_file/of_groups}
    }
    \caption[Usporiadané pole]{Usporiadané pole veľkosti $N$. Strom nad blokmi je len imaginárny a nezostrojuje sa v pamäti.}
    \label{fig:of_overview}
\end{figure}

Nad týmito blokmi zostrojíme (imaginárny) úplný binárny strom (obrázok \ref{fig:of_overview}). \emph{Hĺbkou} vrcholu označíme jeho vzdialenosť od koreňa, pričom koreň má hĺbku $0$ a listy majú hĺbku $d = h-l$. Na popis operácií budeme potrebovať definície \emph{hustoty} a \emph{hraníc hustoty}, ktoré uvedieme v nasledovnej časti.

\subsection{Definícia hustoty}

\emph{Kapacitou} vrcholu $v$, $c(v)$, označíme počet položiek (aj prázdnych) poľa patriacich do blokov v podstrome začínajúcom v tomto vrchole. Kapacita listov bude teda $S$, ich rodičov $2S$ a kapacita koreňa bude $T$. Podobne budeme počet neprázdnych položiek v podstrome vrcholu $v$ volať \emph{obsadnosť} a značiť $o(v)$. 

\emph{Hustotou}, $0 \le d(v) \le 1$, označíme $d(v) = \frac{o(v)}{c(v)}$. Zvoľme ľubovoľné konštanty $\rho_0, \tau_0, \rho_d, \tau_d$ spĺňajúce
\[
0 < \rho_d < \rho_0 < \tau_0 < \tau_d < 1
\]

Z týchto konštánt definujeme pre vrchol s hĺbkou $k$ \emph{dolnú} a \emph{hornú hranicu hustoty} ($\rho_k$ a $\tau_k$) následovne:
\[
\rho_k = \rho_0 + \frac{k}{d}(\rho_d-\rho_0) \qquad
\tau_k = \tau_0 - \frac{k}{d}(\tau_0-\tau_d)
\]

Dostaneme tak postupnosť hraníc pre všetky hĺbky, pričom platí $(\rho_i,\tau_i) \subset (\rho_{i+1},\tau_{i+1})$ a teda sa tieto intervaly smerom od listov ku koreňu zmenšujú:
\[
0 < \rho_d < \rho_{d-1} < \cdots < \rho_0 < \tau_0 < \tau_1 < \cdots < \tau_d < 1
\]

Hovoríme, že vrchol $v$ hĺbky $k$ je \emph{v hraniciach} hustoty ak platí $\rho_k \le d(v) \le \tau_k$.

\subsection{Operácie}
\subsubsection{Vkladanie}

Implementácia operácie vkladania sa skladá z niekoľkých krokov. Najskôr zistíme, do ktorého bloku $v$ spadá pozícia, na ktorú vkladáme. Pozrieme sa, či je tento blok v hraniciach hustoty. Ak áno tak platí $d(v) < 1$ a teda $o(v) < c(v)$, čiže v tomto bloku je voľné miesto. Môžeme teda zapísať novú hodnotu do tohto bloku, pričom môže byť potrebné hodnoty v bloku popresúvať, avšak zmení sa najviac $S = \Theta(\log{N})$ pozícii.

V opačnom prípade je tento blok mimo hraníc hustoty. Budeme postupovať hore v strome dovtedy, kým nenájdeme vrchol v hraniciach. Keďže strom je iba pomyselný, budeme túto operáciu realizovať pomocou dvoch súčasných lineárnych prechodov k okrajom poľa. Počas tohto prechodu si udržiavame počítadlá neprázdnych a všetkých pozícii, ktoré inicializujeme podľa tohto bloku. Ďalej postupujeme následovne.

V prípade, že je hustota (podiel počítadiel) podstromu reprezentujúceho práve prejdený interval  mimo hraníc hustoty, posunieme sa v pomyselnom strome nahor. To dosiahneme prechodom doľava alebo doprava o práve toľko pozícií ako je veľkosť už prejdeného intervalu. Tento postup ukončíme v momente, keď hustota dosiahne požadované hranice.

Po nájdení takéhoto vrcholu v hraniciach rovnomerne rozdelíme všetky hodnoty v blokoch prislúchajúcich danému podstromu. Keďže intervaly pre hranice sa smerom k listom iba rozširujú budú po tomto popresúvaní všetky vrcholy tohto podstromu v hraniciach hustoty a teda aj požadovaný blok bude obsahovať aspoň jednu prázdnu pozíciu. Môžeme teda novú hodnotu vložiť ako v prvom kroku.

Ak nenájdeme taký vrchol, ktorého hustota by bola v hraniciach, a teda aj koreň je mimo hraníc, je táto štruktúra príliš plná. V takom prípade zostrojíme nové pole dvojnásobnej veľkosti a všetky prvky rovnomerne rozmiestnime do nového poľa.

\subsubsection{Odstraňovanie}

Operácia odstraňovania prebieha analogicky. Ako prvé požadovanú položku odstránime z prislúchajúceho bloku. Ak je tento blok aj naďalej v hraniciach hustoty tak skončíme, inak postupujeme nahor v strome, kým nenájdeme vrchol v hraniciach. Následne rovnomerne prerozdelíme položky blokoch daného podstromu.

Pokiaľ taký vrchol nenájdeme, je pole príliš prázdne a zostrojíme nové polovičnej veľkosti a rovnomerne do neho rozmiestnime zostávajúce položky pôvodného.

\subsection{Analýza}

Pri vkladaní aj odstraňovaní sa upraví súvislý interval $I$, ktorý sa skladá z niekoľkých blokov. Nech pri nejakej operácii došlo k prerozdeleniu prvkov v blokoch prislúchajúcich podstromu vrcholu $u$ v hĺbke $k$. Teda pred týmto prerozdelením bol vrchol $u$ v hraniciach hustoty ($\rho_k \le d(u) \le \tau_k$) ale nejaký jeho potomok $v$ nebol.

Po prerozdelení budú všetky vrcholy v danom podstrome v hraniciach hustoty, avšak nie len v svojich, ale keďže sme prerozdelili podstrom vrcholu $u$, tak aj v hraniciach pre hĺbku $k$, ktoré sú tesnejšie. Bude teda platiť $\rho_k \le d(v) \le \tau_k$. Najmenší počet operácii vloženia, $q$, potrebný na to, aby bol vrchol $v$ opäť mimo hraníc je

\[
\begin{aligned}
\frac{o(v)}{c(v)} = d(v) &\le \tau_k \hspace{3cm} & \frac{o(v)+q}{c(v)} &> \tau_{k+1} \\
o(v) &\le \tau_k c(v) & o(v)+q &> \tau_{k+1}c(v) \\
\end{aligned}
\]\[
q > (\tau_{k+1}-\tau_k)c(v)
\]

Podobne pre prekročenie dolnej hranice je potrebných aspoň $(\rho_k-\rho_{k+1})c(v)$ operácii odstránenia.

Pri úprave intervalu blokov v podstrome vrcholu $u$ je potrebné upraviť najviac $c(u)$ položiek, avšak táto situácia nastane až keď sa potomok $v$ ocitne znovu mimo hraníc hustoty. Priemerná veľkosť intervalu, ktorý treba preusporiadať pri vložení do podintervalu prislúchajúceho vrcholu $v$ teda bude
\[
\frac{c(u)}{(\tau_{k+1}-\tau_k)c(v)} = \frac{2c(v)}{(\tau_{k+1}-\tau_k)c(v)} = \frac{2}{\tau_{k+1}-\tau_k} = \frac{2d}{\tau_d-\tau_0} = \bigO{\log{T}}
\]
keďže $\tau_d$ a $\tau_0$ sú konštanty a výška úplného binárneho stromu $d$ s $T$ listami je $d = \Theta(\log{T})$. Podobným spôsobom dostaneme rovnaký odhad pre odstraňovanie.

Pri vkladaní a odstraňovaní prvku ovplyvníme najviac $d$ podintervalov -- tie, ktoré prislúchajú vrcholom na ceste z daného listu (bloku) do koreňa. Spolu teda bude veľkosť upraveného intervalu v priemernom prípade $\bigO{\log^2{T}}$.

\todo[inline]{worstcase bounds? conjenctured lowerbound?}
\todo[inline]{amortizacia double/half rebuildu}

Táto dátová štruktúra teda udržiava $N$ usporiadaných prvkov v poli veľkosti $\bigO{N}$ a podporuje operácie vkladania a odstraňovania, ktoré upravujú súvislý interval amortizovanej veľkosti $\bigO{\log^2{N}}$ a je ich teda možné realizovať pomocou $\bigO{\frac{\log^2{N}}{B}}$ pamäťových presunov.

\section{Dynamický B-strom} \label{sec:dynamic-obliv}
V tejto sekcií popíšeme dynamickú verziu \obliv vyhľadávacieho stromu. Prvá verzia tejto štruktúry, ktorú navrhli Bender, Demaine \etal v \citep{btreeshort} a neskôr podrobne popísali v \citep{btreefull}, bola však značne komplikovaná a preto uvedieme zjednodušenú verziu. Tú navrhli Bender, Duan \etal v \citep{bender2002} a dosahuje rovnaké výsledky ale jej popis a analýza sú podstatne jednoduchšie.

\subsection{\Aware riešenie}
V prípade \aware modelu môžeme na riešenie tohto problému opäť použiť B-strom s vetvením $\Theta(B)$ ako v časti \ref{sec:static-aware}. Rovnako ako pre vyhľadávanie bude na vkladanie potrebných $\bigO{\log_B{N}}$ pamäťových presunov.

\subsection{Popis \obliv štruktúry}
Túto dátovú štruktúru vytvoríme zložením predchádzajúcich dvoch -- statického stromu (\ref{sec:static-obliv}) a usporiadaného poľa (\ref{sec:of-desc}) -- jednoduchým spôsobom. Majme usporiadané pole veľkosti $\Theta(N)$. Keďže počet položiek v usporiadanom poli je mocnina dvoch, môžeme nad ním vybudovať úplný binárny statický vyhľadávací strom uložený vo \vEB{ovom} usporiadaní. Listy tohto stromu budú prvky usporiadaného poľa (pozri obrázok \ref{fig:cobtree_overview}).

\begin{figure}
    \centering
    \resizebox{\textwidth}{!}{
        \input{figures/dynamic_tree/overview}
    }
    \caption[Dynamický strom]{Dynamický strom, ktorý vznikne spojením usporiadaného poľa a statického stromu vo \vEB{ovom} usporiadaní. Šipky znázorňujú spárovanie listov a položiek pola.}
    \label{fig:cobtree_overview}
\end{figure}

Kľúče, ktoré táto štruktúra obsahuje, sú uložené v usporiadanom poli (s medzerami). Listy statického stromu obsahujú v svojich kľúčoch rovnakú hodnotu ako k ním prislúchajúce položky usporiadaného poľa. Medzeru reprezentujeme hodnotou, ktorá je pri použitom usporiadaní najmenšia (v prípade číselných kľúčov $-\infty$). Ostatné vrcholy stromu obsahujú ako kľúč maximum z kľúčov svojich synov.

\subsection{Vyhľadávanie} \label{sec:dynamic-obliv-search}
Vyhľadávanie v tejto štruktúre prebieha jednoducho. Začínajúc od koreňa, porovnáme hľadaný kľúč s kľúčom v ľavom synovi. Pokiaľ je hľadaný prvok väčší, bude v pravom podstrome (keďže maximum z celého ľavého podstromu je práve kľúč ľavého syna), ktorý rekurzívne prehľadáme. V opačnom prípade prehľadáme ľavý podstrom. Keď dosiahneme list, porovnáme jeho kľúč s hľadaným. Ak sa zhodujú, našli sme požadovanú položku a v opačnom prípade sa v štruktúre nenachádza.

\subsubsection{Analýza}

Toto prehľadávanie prechádza cestu od koreňa k listu v strome hĺbky $\bigO{\log{N}}$ uloženom vo \vEB{ovom} usporiadaní a teda, rovnako ako v časti \ref{sec:static-search}, vykoná $\bigO{\log_B{N}}$ pamäťových presunov.

\subsection{Vkladanie}
Zaujímavejšou operáciou je vkladanie, ktoré v pôvodnom statickom strome nebolo možné. Prvým krokom je nájdenie pozície, na ktorú tento kľúč patrí. To dosiahneme podobne ako v predošlej sekcii. Budeme ale hľadať predchádzajúci a nasledujúci kľúč. Tým nájdeme v usporiadanom poli dvojicu pozícii, medzi ktoré chceme vložiť novú hodnotu.

Vloženie do usporiadaného pola zmení súvislý interval veľkosti $K$. Následne bude potrebné aktualizovať kľúče v statickom strome, aby opäť obsahovali maximum zo svojich synov. Túto aktualizáciu dosiahneme takzvaným \emph{post-order} prechodom, kedy sa vrchol aktualizuje až po tom, čo boli aktualizovaní jeho synovia. Tým máme zaručené, že po aktualizácii vrchol obsahuje výslednú, korektnú hodnotu. Implementácia takéhoto prechodu je naznačená v algoritme \ref{alg:postorder}.

\begin{algorithm}
    \caption{Implementácia \emph{post-order} prechodu na aktualizáciu statického stromu}
    \label{alg:postorder}
    \begin{algorithmic}[1]
        \Function{update}{$v$, $I$} \Comment{$v$ je vrchol stromu, ktorý práve aktualizujeme}
        \Statex \Comment{$I$ je zmenený interval v usporiadanom poli}
        \Statex
            \If{$v$.podstrom $\cap~ I = \emptyset$} \Comment{pokiaľ sa zmena tohto vrcholu}
                \State \Return \Comment{určite nedotkla, tak ho môžeme preskočiť}
            \EndIf
            \Statex
            \If{$v$ je list}
                \AlgLet{$v$.kľuč}{hodnota z usporiadaného poľa}
            \Else
                \State \Call{update}{$v$.ľavý} \Comment{najskôr aktualizujeme ľavého}
                \State \Call{update}{$v$.pravý} \Comment{a pravého syna}
                \Statex
                \AlgLet{$v$.kľúč}{$\max(v$.ľavý.kľúč$, v$.pravý.kľúč$)$} \Comment{až potom tento vrchol}
            \EndIf           
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\subsection{Analýza vkladania}

\begin{figure}
    \centering
    \resizebox{\textwidth}{!}{
        \input{figures/dynamic_tree/three_parts}
    }
    \caption[Rozdelenie statického stromu]{Rozdelenie statického stromu na tri časti pri analýze počtu pamäťových presunov.}
    \label{fig:cobtree_analysis_parts}
\end{figure}

Túto analýzu rozdelíme na tri časti (obrázok \ref{fig:cobtree_analysis_parts}), v ktorých sa postupne pozrieme na rôzne úrovne v statickom strome, ktoré treba po vložení do usporiadaného pola aktualizovať. Budeme predpokladať, že veľkosť zmeneného intervalu v usporiadanom poli je $K$. Pre jednotlivé úrovne spočítame počet potrebných pamäťových presunov a nakoniec ich sčítaním získame výslednú zložitosť operácie vkladania.

\subsubsection{Spodné dve úrovne}
Uvažujme najskôr ako v časti \ref{sec:static-search} také podstromy \vEB{ovho} delenia, ktorých veľkost je medzi $\sqrt{B}$ a $B$, a teda sa zmestia do najviac dvoch blokov v \cache. Pozrime sa na spodné dve úrovne takýchto podstromov (na obrázku \ref{fig:cobtree_analysis_parts} reprezentovan0 najmenšími trojuholníkmi). Listy spodnej úrovne budú listy celého statického stromu a korene spodnej spodnej úrovne budú synovia listov hornej úrovne. Zvyšok stromu pokračuje nad týmito úrovňami a vrátime sa k nemu neskôr.

Podstromy v tomto delení sa zmestia do najviac dvoch blokov a vieme ich teda načítať pomocou $\bigO{1}$ pamäťových presunov. Tieto podstromy vznikli rekurzívnym \vEB{ovým} delením z podstromu $T$ veľkosti viac než $B$. Označme ich, rovnako, ako v časti \ref{sec:static-obliv}, $\tau_0, \tau_1, \dotsc, \tau_k$, pričom $\tau_0$ je podstrom v hornej úrovni a $\tau_1,\dotsc,\tau_k$ sú podstromy v spodnej úrovni, ktorých korene sú potomkovia listov $\tau_0$.

Pri \emph{post-order} prechode cez podstrom $T$ prejdeme najskôr cez ľavých synov od koreňa $\tau_0$ cez $\tau_1$ až do listu. Následne bude \emph{post-order} prechod prebiehať v podstrome $\tau_1$, až kým nebudú všetky jeho vrcholy a napokon aj koreň aktualizované. Až potom sa vrátime do $\tau_0$ a k $\tau_1$ už viac pristupovať nebudeme, ale prejdeme nasledovný podstrom, $\tau_2$. Takto postupne aktualizujeme všetky podstromy, pričom postupnosť navštívených podstromov bude
\[
\tau_0, \tau_1, \tau_0, \tau_2, \dotsc, \tau_0, \tau_i, \tau_0, \dotsc, \tau_k, \tau_0
\]

Vidíme, že pokiaľ dokážeme udržať v \cache aspoň dva také podstromy, teda za predpokladu $M \ge 4B$, sme schopný takýto \emph{post-order} prechod zrealizovať pomocou $\bigO{1}$ pamäťových operácii pre každý podstrom veľkosti $\le B$. Takéto podstromy majú $\bigO{B}$ listov, pričom  nimi potrebujeme pokryť interval veľkosti $K$ (podstromy, ktorých žiaden list neleží v upravenom intervale nie je potrebné aktualizovať) a teda celkový počet podstromov na spodných dvoch úrovniach, ktoré potrebujeme načítať a upraviť je $\bigO{\frac{K}{B}}$ a stačí nám na to $\bigO{\frac{K}{B}}$ pamäťových presunov.

\subsubsection{Stredná časť -- najbližší spoločný predok}
Označme ako $T_1,\dotsc,T_\ell$ tie stromy, ktoré obsahujú aktualizované podstromy veľkosti najviac $B$ na spodných dvoch úrovniach. Platí teda $\ell = \bigO{\frac{K}{B}}$. Označme $U$ taký podstrom statického stromu, ktorého koreň je najbližší spoločný predok koreňov $T_1,\dotsc,T_\ell$. Ak je tento koreň v hĺbke $h$ tak $U$ obsahuje všetky vrcholy hĺbky aspoň $h$, ktoré treba aktualizovať - tie mimo $U$ nie sú predkovia upravených vrcholov a teda hodnoty kľúčov ich potomkov neboli v prvej časti zmenené, alebo už boli aktualizované ako súčasť nejakého podstromu $T_i$ na spodnej úrovni.

Počet vrcholov $U$ je najviac dvojnásobok počtu listov a teda $|U| = \bigO{l} = \bigO{\frac{K}{B}}$. Keďže pri \emph{post-order} prechode navštívime každý vrchol $\bigO{1}$ krát (najprv pri prechode z koreňa ku listom, pričom následne rekurzívne prejdeme ľavého a pravého syna, a potom pri návrate z rekurzie) a teda celkovo budeme potrebovať $\bigO{\frac{K}{B}}$ pamäťových presunov na aktualizáciu $U$.

\subsubsection{Horná časť -- cesta z najbližšieho spoločného predka do koreňa}
Posledná množina vrcholov, ktoré je potrebné aktualizovať,     je cesta z koreňa $U$ do koreňa statického stromu. Dĺžka tejto cesty je obmedzená výškou stromu $\bigO{\log{N}}$ a pri aktualizovaní prechádzame cez jej vrcholy postupne. Podobne ako pri vyhľadávaní (časť \ref{sec:dynamic-obliv-search}) bude potrebných $\bigO{\log_B{N}}$ pamäťových presunov.

\subsubsection{Výsledná zložitosť}
Sčítaním nasledovných zložitostí počtu pamäťových operácii
\[
\begin{aligned}
&\text{Nájdenie pozície v usporiadanom poli:} ~~ &&\bigO{\log_B{N}} \\
&\text{Vloženie do usporiadaného poľa:} &&\bigO{\frac{K}{B}} \\
&\text{Aktualizácia spodných dvoch úrovní:} &&\bigO{\frac{K}{B}} \\
&\text{Aktualizácia strednej úrovne:} &&\bigO{\frac{K}{B}} \\
&\text{Aktualizácia hornej úrovne:} &&\bigO{\log_B{N}} \\
\end{aligned}
\]
dostávame celkovú zložitosť $\bigO{\log_B{N} + \frac{K}{B}}$. Keďže amortizovaná veľkosť upraveného intervalu je $K = \bigO{\log^2{N}}$ dostávame výslednú amortizovanú zložitosť počtu pamäťových operácii pri vkladaní: $\bigO{\log_B{N} + \frac{\log^2{N}}{B}}$.

\subsection{Odstraňovanie}
Algoritmus odstraňovania je analogický, po nájdení prvku v usporiadanom poli ho odstránime, čím sa zmení súvislý interval amortizovanej veľkosti $\bigO{\log^2{N}}$. Následne aktualizujeme kľúče v statickom poli rovnako ako pri vkladaní. Výsledná zložitosť bude taktiež rovnaká.

\todo[inline]{double/half}

\section{Vylepšený dynamický B-strom} \label{sec:dynamic-obliv-improved}
\epigraph{Any problem in computer science can be solved with another level of indirection.}{David Wheeler}
Oproti \aware B-stromom má pri vkladaní \obliv dynamický strom popísaný v predchádzajúcej sekcii naviac $\bigO{\frac{\log^2{N}}{B}}$ pamäťových presunov. V prípade, že $B=\Theta(\log{N}\log\log{N})$, bude tento člen zanedbateľný a dosiahneme rovnaký výsledok ako \aware B-stromy. Jednoduchou modifikáciou však môžeme tento člen môžeme odstrániť bez nutnosti tohto predpokladu.

Vezmeme $N$ kľúčov a rozdelíme ich do $\Theta(\frac{N}{\log{N}})$ blokov veľkosti $\Theta(\log{N})$. Minimum z každej skupiny použijeme ako kľúče v predchádzajúcej dátovej štruktúre, ktorej veľkosť bude $\Theta(\frac{N}{\log{N}})$.

\subsection{Vyhľadávanie}
Najskôr vyhľadáme požadovaný blok v B-strome, čo zaberie $\bigO{\log_B{\frac{N}{\log{N}}}} = \bigO{\log_B{N}}$ pamäťových presunov. Následne prejdeme daný blok celý a nájdeme v ňom požadovaný kľúč. To vyžaduje $\bigO{\frac{\log{N}}{B}}$ pamäťových presunov - zanedbateľné voči hľadaniu v B-strome - a spolu teda vyhľadávanie vyžaduje rovnako veľa pamäťových presunov ako neupravený B-strom: $\bigO{\log_B{N}}$. \todo{popis najdenia bloku - min/max, left child, ...}

\subsection{Vkladanie a odstraňovanie}
Po nájdení požadovaného bloku vykonáme vloženie prípadne odstránenie z neho kompletným prepísaním, čo vyžaduje $\bigO{\frac{\log{N}}{B}}$ presunov. Zároveň budeme udržiavať veľkosti blokov medzi $\frac{1}{4}\log{N}$ a $\log{N}$. Príliš malé skupiny môžeme spojiť do väčších a veľké rozdeliť na niekoľko menších. Skupina prekročí svoje hranice najskôr po $\Omega(\log{N})$ operáciách. V takom prípade po rozdelení alebo spojení bude potrebné vykonať vloženie alebo odstránenie z B-stromu. Vydelením dostávame amortizovanú zložitosť vkladania a odstraňovania:
\[
\bigO{\frac{\log_B{N} + \frac{\log^2{N}}{B}}{\log{N}}} = \bigO{\frac{\log{N}}{B}}
\]

Najskôr však musíme nájsť blok, ktorý budeme aktualizovať. Teda výsledná zložitosť bude $\bigO{\log_B{N}}$ rovnako ako pri \aware B-strome. Opäť sme teda dosiahli rovnaký počet operácií ako ekvivalentná \aware dátová štruktúra, avšak tentokrát nie v najhoršom ale  amortizovanom prípade.
%Vydelením dostaneme amortizovanú zložitosť vkladania a odstraňovania v takto upravenej štruktúre: $\bigO{\log_B{N}}$.



% OUTLINE
%- static search trees
%  - aware solution - btree
%  - naive solution - too slow
%  - obliv solution
%    - vEB layout
%      - indexing - pointers vs compute position
%    - analysis
%- ordered file
%  - desc
%  - analysis
%- dynamic search tree
%  - aware solution - btree again
%  - basic version
%    - analysis
%  - indirection
%    - analysis

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% OLD %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%\section{Matice}
%
%\subsection{Násobenie matíc}
%
%Ďalším jednoduchým \obliv algoritmom je násobenie matíc. Majme dve matice $A, B$ typu $N \times N$ a chceme vypočítať ich súčin $S = A \cdot B$. Klasický algoritmus bude pri výpočte každého prvku $S$ postupne prechádzať maticu $A$ po riadkoch a maticu $B$ po stĺpoch. Za predpokladu, že sa do cache súčasne zmestia aspoň tri bloky - po jednom z matíc $A$ a $B$, a jeden blok $S$ obsahujúci prvok, ktorý práve počítame - budeme na každý prvok $S$ potrebovať najviac $\bigO{1+N/B}$ presunov. Celkovo teda vykonáme najviac $\bigO{N^2 + N^3/B}$ pamäťových presunov. 
%
%\
%
%\todo[inline]{Doplniť \obliv verziu + analýzu}
%
%%\subsection{Invertovanie matíc}
%
%\section{Stromy}
%\subsection{Statické stromy}
%
%\todo[inline]{...}
%
%%\subsubsection{Packed memory array}
%%\subsubsection{B-Stromy}
%
%%\subsubsection{Prioritné fronty} % funnel heap?
%
%\section{Triedenie}
%
%V \aware modely pamäte je spodným odhadom na počet pamäťových presunov pri triedení porovnávaním $\Theta(\frac{N}{B}log_{M/B}\frac{N}{B})$. \citep{AggVitt88, Demaine02}. Algoritmus, ktorý túto hranicu dosahuje je $M/B$-cestný mergesort (triedenie zlučovaním). Na rozdiel od klasického mergesortu si pri zlučovaní pamätá $B$ prvkov z každého z $M/B$ zoznamov a pri vyprázdnení načíta opäť cely blok s $B$ prvkami. Zlúčenie listov celkovej dĺžky $N$ teda vyžaduje $\bigO{N/B}$ pamäťových presunov.
%
%\
%
%Avšak \obliv algoritmy musia fungovať bez znalosti $M$ a $B$ a teda bez možnosti vypočítať $M/B$, najväčší počet zoznamov, ktoré môžeme súčasne zlučovať a pamätať si z každého $B$ prvkov v cache. Najlepšie, čo môžeme predpokladať je $M/B \ge 2$, teda vieme aspoň dva zoznamy zlučovať. Teda implementácia $2$-cestného mergesort algoritmu je \obliv, a funguje pre ľubovolné parametre. Avšak počet pamäťových presunov bude $\Theta(\frac{N}{B}log_{2}\frac{N}{B})$, to znamená, že zväčšenie $M$ tento algoritmus nezrýchli, keďže využívame vždy iba malú časť cache. 
%
%\
%
%Ideálny \obliv algoritmus by dosahoval rovnakú, optimálnu hranicu počtu presunov ako $M/B$-cestný mergesort, no bez znalosti týcho parametrov. Jedným z takýchto efektívnych \obliv algoritmov je takzvaný {\em funnel sort} - lievikové triedenie. Skôr ako ho môžeme popísať však potrebujeme definovať dátovú štruktúru {\em funnel} (lievik).
%
%\subsection{Funnel}
%
%K-lievik nazveme štruktúru, ktorá je na vstupe dostane $K$ usporiadaných zoznamov, s celkovou dĺžkou $K^3$ a skombinuje tieto prvky do jedného, usporiadaného výstupného zoznamu, pričom použije najviac $\bigO{\frac{K^3}{B} log_{M/B} \frac{K^3}{B} + K}$ pamäťových operácií.
%
%\
%
%Reprezentácia $K$-lievika bude úplný binárny strom s $K$ listami, uložený v pamäti vo van Emde Boasovom usporiadaní, ako pri statických stromoch (rekurzívne podstromy veľkosti $\sqrt{K}$). Hrany medzi vnútornými rekurzívnymi podstromami si uchovávajú {\em buffer} (pomocné pole) veľkosti $K^{3/2}$, pričom podstromov je $\sqrt{K}$ a teda spolu potrebujú $K^2$ pamäte. V podstromoch, ktoré tvoria $\sqrt{K}$-lieviky, sú všetky buffery rekurzívne menšie.
%
%\
%
%Spolu teda $K$-lievik potrebuje $S(K)$ pamäte. Každý sa skladá z $1+\sqrt{K}$ podstromov, ktoré reprezentujú $\sqrt{K}$-lieviky a teda $S(K) = (1+\sqrt{K})S(\sqrt{K}) + K^2$. Z toho jednoducho dostaneme, že veľkosť $K$-lievika v pamäti je $\bigO{K^2}$.
%
%\
%
%\todo[inline]{Obrázok + analýza počtu pamäťových presunov}
%
%\subsection{Funnelsort}
%
%Vezmime vstupné pole veľkosti $N$ a rozdelme ho na $K = N^{1/3}$ súvislých segmentov. Veľkosť každého bude $N^2/3$. Následne rekurzívne utriedime tieto segmenty. Pre ich spojenie použijeme $K$-lievik, ktorého výstupom bude usporiadané pole.
%
%\
%
%Počet pamäťových presunov bude
%\[
%T(N) = N^{1/3}T(N^{2/3}) + \bigO{\frac{N}{B} log_{M/B} \frac{N}{B} + N^{1/3}}
%\]
%keďže rozdelenie poľa je voči spájaniu zanedbateľné. Táto rekurencia platí pre $N > M$. V prípade, že sa cele pole zmestí do cache, teda $N \le M$, a za predpokladu $M \ge B^2$, dostávame $T(N) = T(B^2) = \bigO{B}$. Celkové riešenie tejto rekurencie, a teda výsledný počet pamäťových presunov potrebných na usporiadanie poľa veľkosti $N$ je $\bigO{\frac{N}{B} log_{M/B} \frac{N}{B}}$.




%\begin{figure}
%    \centering
%    
%    \subbottom[Abc] {
%        \resizebox{0.4\textwidth}{!}{
%            \input{figures/vEB_tree/vEBlayout_scheme}
%        }
%    }
%    \subbottom[Def] {
%        \resizebox{0.4\textwidth}{!}{
%            \input{figures/vEB_tree/vEBlayout_scheme}
%        }
%    }
%    \caption{Test}
%\end{figure}
